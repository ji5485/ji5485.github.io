{
    "componentChunkName": "component---src-page-template-blog-post-item-template-tsx",
    "path": "/post/2024-01-10/develop-ranking-system-using-redis-sorted-set/",
    "result": {"data":{"markdownRemark":{"html":"<h3 id=\"랭킹-시스템-개발-배경\" style=\"position:relative;\"><a href=\"#%EB%9E%AD%ED%82%B9-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B0%9C%EB%B0%9C-%EB%B0%B0%EA%B2%BD\" aria-label=\"랭킹 시스템 개발 배경 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>랭킹 시스템 개발 배경</h3>\n<p>처음 서비스 개발을 시작한 제작년, 서비스 활성도 증가를 위한 일일 미션과 포인트 제도에 대한 기획이 나와 해당 기능을 개발해야 했었습니다.</p>\n<p>당시 유저 테이블에 포인트 데이터를 함께 저장하도록 기획했기 때문에 처음 코드를 작성할 때에는 제대로 된 백엔드 트래픽을 느껴본 적이 없기도 했고, 관련 지식도 거의 없다시피 했기에 단순히 SQL로만 랭킹 조회 기능을 구축했었습니다.</p>\n<p>그래서 저때 개발한 기능은 랭킹 시스템이라고 부르기도 애매했습니다.</p>\n<p>그래도 어찌저찌 기능은 잘 동작하고, 서비스 오픈 후로도 유저 수가 크게 증가하는 과정에서도 문제가 없었기 때문에 개선할 생각 없이 쭉 방치해왔지만 어느 순간 이로 인해 조금씩 문제가 생기기 시작했습니다.</p>\n<p>조금씩 발견되는 문제점으로 인해 인덱스를 설정할까 했지만 초대 시스템이 존재했기 때문에 자신이 직접 포인트를 취득하지 않고서도 다른 유저에 의해 포인트가 쌓이는 상황이 빈번하게 발생해서 결국 인덱스를 설정하지 않았습니다.</p>\n<p>그러다 결국 데이터 수가 1000만개도 되지 않는 상황에서도 TOP 100 목록을 조회하는데 기본적으로 2~3초가 걸릴 정도로 속도가 많이 느려졌고, 트래픽이 높아지면 유저의 개인 랭킹을 조회하는 부분에서 심한 병목이 발생했습니다.</p>\n<p>덕분에 데이터베이스의 응답이 계속 지연되면서 서버도 같이 문제가 되고, 일단 해당 기능을 비활성화 하고나서 개선 방안을 생각하기 시작했습니다.</p>\n<h3 id=\"redis의-sorted-set\" style=\"position:relative;\"><a href=\"#redis%EC%9D%98-sorted-set\" aria-label=\"redis의 sorted set permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redis의 Sorted Set</h3>\n<p>랭킹 시스템을 구축하기 위해 구글링을 해봤는데, 대부분의 포스트에서 Redis의 Sorted Set을 사용했었습니다.</p>\n<p>Sorted Set은 이름에서도 확인할 수 있듯이 순서가 보장되지 않고, 고유한 값을 저장하는 Set 자료구조에 정렬 기능이 포함되어 있는 자료구조입니다.</p>\n<p>key 하나에 여러 개의 score와 member가 존재하고, 기본적으로 score 기준으로 정렬되지만 중복되는 경우에는 member를 기준으로 정렬됩니다.</p>\n<p>보기에는 특별한 점 없어보이지만 레코드 정렬을 위한 ORDER BY를 사용한 SQL문과 정렬된 데이터 조회를 위한 Redis의 ZRANGE의 시간복잡도를 비교하면 큰 차이가 존재한다는 것을 쉽게 확인할 수 있습니다.</p>\n<p>일반적인 상황에서 ORDER BY를 사용한 SQL문의 시간복잡도는 O(N logN)이고, Redis의 ZRANGE의 시간복잡도는 O(logN + M)입니다.</p>\n<p>이렇게만 생각해봐도 엄청나게 큰 차이가 느껴질테지만 시간복잡도 그래프를 보시면 어마어마한 차이라는 것을 느끼실 수 있습니다.</p>\n<br />\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 768px; \n        width: 100%;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.15);\n      \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c77f92fa9f3d0b60c1e98df0cbef6906/3fbc1/develop-ranking-system-using-redis-sorted-set-1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABAUlEQVQoz6VSWW7FIAzM/c/aJGBsMEs1lZ2laZT31Kofo7HMMF5gKqWAiNDHQFWFEqH1jtbaid47aq3O1/wdpplyzogxuqEyQ0VOQxNcxQc/5U9DEUEIwQ0LEWopPy5eje6GT5rJAjMdvUNT8rEOHONe4+sanjQTM2MNAU116/BW+VWHT1BVTBZIzmhZfNx/d2jjxhBQmf2V3+3nVzu0b3MavhjtT4ZaK2ieMapijOGPM0b3uF9i48+dv3FoxqnxDpePBYkzAjEiMSgJQkwgzlhjQpKCJdCWJ3bYmed2jfG8xs3QBJLVLxALkmRQYrAURONcvJDnWVznZ2SavHNBiIQv2i1a0q8Sq+UAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/c77f92fa9f3d0b60c1e98df0cbef6906/a59e9/develop-ranking-system-using-redis-sorted-set-1.webp 192w,\n/static/c77f92fa9f3d0b60c1e98df0cbef6906/0ca9f/develop-ranking-system-using-redis-sorted-set-1.webp 384w,\n/static/c77f92fa9f3d0b60c1e98df0cbef6906/dc9b9/develop-ranking-system-using-redis-sorted-set-1.webp 768w,\n/static/c77f92fa9f3d0b60c1e98df0cbef6906/e2c2f/develop-ranking-system-using-redis-sorted-set-1.webp 1152w,\n/static/c77f92fa9f3d0b60c1e98df0cbef6906/f3efb/develop-ranking-system-using-redis-sorted-set-1.webp 1536w,\n/static/c77f92fa9f3d0b60c1e98df0cbef6906/9620e/develop-ranking-system-using-redis-sorted-set-1.webp 2186w\"\n              sizes=\"(max-width: 768px) 100vw, 768px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/c77f92fa9f3d0b60c1e98df0cbef6906/3b721/develop-ranking-system-using-redis-sorted-set-1.png 192w,\n/static/c77f92fa9f3d0b60c1e98df0cbef6906/66595/develop-ranking-system-using-redis-sorted-set-1.png 384w,\n/static/c77f92fa9f3d0b60c1e98df0cbef6906/fe486/develop-ranking-system-using-redis-sorted-set-1.png 768w,\n/static/c77f92fa9f3d0b60c1e98df0cbef6906/d2d74/develop-ranking-system-using-redis-sorted-set-1.png 1152w,\n/static/c77f92fa9f3d0b60c1e98df0cbef6906/e8464/develop-ranking-system-using-redis-sorted-set-1.png 1536w,\n/static/c77f92fa9f3d0b60c1e98df0cbef6906/3fbc1/develop-ranking-system-using-redis-sorted-set-1.png 2186w\"\n            sizes=\"(max-width: 768px) 100vw, 768px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/c77f92fa9f3d0b60c1e98df0cbef6906/fe486/develop-ranking-system-using-redis-sorted-set-1.png\"\n            alt=\"./develop-ranking-system-using-redis-sorted-set-1.png\"\n            title=\"./develop-ranking-system-using-redis-sorted-set-1.png\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<br />\n<h3 id=\"중복이-없다는-특징으로-인한-동점자-처리-문제\" style=\"position:relative;\"><a href=\"#%EC%A4%91%EB%B3%B5%EC%9D%B4-%EC%97%86%EB%8B%A4%EB%8A%94-%ED%8A%B9%EC%A7%95%EC%9C%BC%EB%A1%9C-%EC%9D%B8%ED%95%9C-%EB%8F%99%EC%A0%90%EC%9E%90-%EC%B2%98%EB%A6%AC-%EB%AC%B8%EC%A0%9C\" aria-label=\"중복이 없다는 특징으로 인한 동점자 처리 문제 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>중복이 없다는 특징으로 인한 동점자 처리 문제</h3>\n<p>Sorted Set을 사용하면 모든게 해결될 줄 알았지만 아쉽게도 해결해야 하는 문제가 하나 있습니다.</p>\n<p>바로 동점자가 생기는 부분인데요, Sorted Set에서 동일한 점수에 대해서는 member를 기준으로 정렬되므로 동점자가 있는 경우에 member를 통해 인덱스 값을 조회하는 ZRANK 명령어를 사용하면 올바른 랭킹이 뜨지 않을 수 있습니다.</p>\n<p>이를 방지하기 위해 다양한 동점자 처리 방식이 존재하는데, 아래와 같이 처리가 가능합니다.</p>\n<ol>\n<li>\n<p>아무런 처리 없이 member를 통한 정렬 사용하기</p>\n<p>이 방법은 서버 단에서 부가적인 동점자 처리 없이 Redis 명령어를 통해 조회한 순위를 그대로 사용하는 방법입니다.</p>\n</li>\n<li>\n<p>공동 순위로 처리</p>\n<p>단순히 점수가 동일한 경우에는 공동 순위로 처리할 수 있습니다.</p>\n<p>대신 순위를 구하기 위해서는 ZRANK 명령어 대신, 자신의 스코어보다 높은 유저들의 수를 구한 값에 1을 더한 값을 랭킹값으로 처리하면 됩니다.</p>\n</li>\n<li>\n<p>소수점을 통한 순위 조정</p>\n<p>스코어는 정수값이 아닌 소수값으로도 설정이 가능한데, 이를 통해 세부적으로 순위를 조정할 수 있습니다.</p>\n<p>이를 활용하면 다양한 스코어를 하나의 소수값으로 변환해 세심하게 랭킹을 조정하는 것이 가능합니다.</p>\n<p>대신 유저에게 순위를 보여주기 위해 소수점을 제거하는 추가적인 과정이 필요합니다.</p>\n</li>\n</ol>\n<h3 id=\"nodejs-환경에서-랭킹-시스템-구현하기\" style=\"position:relative;\"><a href=\"#nodejs-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EB%9E%AD%ED%82%B9-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\" aria-label=\"nodejs 환경에서 랭킹 시스템 구현하기 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Node.js 환경에서 랭킹 시스템 구현하기</h3>\n<p>그럼 본격적으로 Redis를 사용해 랭킹 시스템을 구현해봅시다.</p>\n<p>기본적으로 포인트 시스템을 운영하는 경우, 포인트를 갱신하는 과정에서 Redis에도 업데이트를 해줘야 하기 때문에 업데이트 구문에 아래와 같이 ZADD 명령어를 사용해줘야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">updatePoint</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">userId<span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span> point<span class=\"token operator\">:</span> number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// SQL 포인트 업데이트 구문</span>\n\t\n\t<span class=\"token comment\">// Redis에도 업데이트</span>\n\t<span class=\"token keyword\">await</span> redis<span class=\"token punctuation\">.</span><span class=\"token function\">zadd</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ranking'</span><span class=\"token punctuation\">,</span> point<span class=\"token punctuation\">,</span> userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그리고 포인트가 높은 순으로 랭킹을 조회하기 위해 아래와 같이 ZREVRANGE 명령어를 사용해줍시다.</p>\n<p>저는 랭킹 시스템을 구현할 때, 동점자를 공동 순위로 처리했기 때문에 해당 로직도 추가해줬습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> chunk <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'lodash'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">RankingItemType</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  userId<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  point<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  rank<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getRanking</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n<span class=\"token operator\">:</span> number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// WITHSCORES 옵션을 추가하면 아래와 같은 형식으로 데이터가 반환된다.</span>\n\t<span class=\"token comment\">// ['user_a', '1500', 'user_b', '1200', 'user_c', '1000', ...]</span>\n\t<span class=\"token keyword\">const</span> ranking <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> redis<span class=\"token punctuation\">.</span><span class=\"token function\">zrevrange</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ranking'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'WITHSCORES'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token function\">chunk</span><span class=\"token punctuation\">(</span>ranking<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token generic-function\"><span class=\"token function\">reduce</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>RankingItemType<span class=\"token operator\">>></span></span></span><span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span><span class=\"token parameter\">result<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>userId<span class=\"token punctuation\">,</span> point<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> index</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span> userId<span class=\"token punctuation\">,</span> point<span class=\"token operator\">:</span> <span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>point<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> rank<span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 기본적으로 ranking 값이 내림차순으로 정렬되어있기 때문에 기본적으로 index 값으로 순위를 지정할 수 있다.</span>\n        <span class=\"token comment\">// 따라서 바로 이전 내역의 포인트와 동일하면 공동 순위로 설정하고 다르면 index + 1로 설정한다.</span>\n        <span class=\"token keyword\">const</span> rank <span class=\"token operator\">=</span> result<span class=\"token punctuation\">[</span>index <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>point <span class=\"token operator\">===</span> <span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>point<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> result<span class=\"token punctuation\">[</span>index <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>rank <span class=\"token operator\">:</span> index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>result<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> address<span class=\"token punctuation\">,</span> point<span class=\"token operator\">:</span> <span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>point<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> rank <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그럼 이제 특정 유저의 순위를 알고 싶은 경우도 생길 수 있습니다.</p>\n<p>해당 경우는 동점자 처리 방법에서 설명한 것과 같이 자신의 스코어보다 높은 유저들의 수를 구한 값에 1을 더한 값을 자신의 순위로 설정하면 쉽게 처리가 가능합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getRankingByUserId</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">userId<span class=\"token operator\">:</span> string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// ZCOUNT 명령어를 통해 스코어가 user.point + 1 이상인 유저의 수를 쉽게 구할 수 있다.</span>\n  <span class=\"token keyword\">const</span> count <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> redis<span class=\"token punctuation\">.</span><span class=\"token function\">zcount</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ranking'</span><span class=\"token punctuation\">,</span> user<span class=\"token punctuation\">.</span>point <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'+inf'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">return</span> count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"서비스-중단-없이-데이터베이스와-싱크-맞추기\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%A4%91%EB%8B%A8-%EC%97%86%EC%9D%B4-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%99%80-%EC%8B%B1%ED%81%AC-%EB%A7%9E%EC%B6%94%EA%B8%B0\" aria-label=\"서비스 중단 없이 데이터베이스와 싱크 맞추기 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서비스 중단 없이 데이터베이스와 싱크 맞추기</h3>\n<p>이제 랭킹 시스템을 모두 구현했다고 가정해봅시다.</p>\n<p>그럼 어떻게 Redis의 랭킹 데이터와 데이터베이스에 저장된 유저 포인트의 싱크를 서비스의 중단 없이 맞출 수 있을까요?</p>\n<p>빠르게 데이터의 싱크를 맞추기 위해 따로 데이터 삽입을 위한 배치 서버 없이 대용량 데이터를 손쉽게 추가하기 위한 목적으로 Redis의 Pipeline 기능을 사용했습니다.</p>\n<p>Redis는 TCP 프로토콜을 사용하기 때문에 하나의 명령어를 호출하면 그에 대한 응답을 기다려야 합니다.</p>\n<p>따라서 명령어를 5번 호출하면 요청을 보내고 응답을 받는 과정을 총 5번 반복하게 되는 것입니다.</p>\n<p>Pipeline은 위의 문제를 해결하기 위해 한 번에 여러 명령을 실행시켜 성능을 향상시킬 수 있는 기능입니다.</p>\n<p>이번 서비스를 개발하면서 삽입한 데이터의 수인 540만개 기준으로 Pipeline 기능을 사용했을 때 걸린 시간은 대략 1초 정도로, Pipeline 기능을 사용하면 무척 빠른 속도로 여러 명령을 한 번에 실행시킬 수 있습니다.</p>\n<p>그럼 이제 어떤 순서로 데이터베이스와 Redis 간의 싱크를 맞출 수 있었는지 알아봅시다.</p>\n<ol>\n<li>데이터베이스의 유저 테이블 데이터 Export</li>\n<li>해당 데이터로부터 각 유저별로 ZADD 명령어를 하나의 txt 파일에 생성</li>\n<li>CLI에 접속하여 Redis Pipeline을 통해 ZADD 명령어 집합 실행</li>\n<li>랭킹 시스템 반영본 배포</li>\n<li>1번에서 실시한 데이터 Export 시점 이후에 갱신된 데이터에 대해 Redis에 반영</li>\n</ol>\n<p>하지만 데이터가 훨씬 많은 경우에는 위의 과정으로는 안정적으로 데이터의 싱크를 맞추기 어려워 아래와 같이 단계적으로 랭킹 시스템을 적용하는 과정이 필요할 것 같습니다.</p>\n<ol>\n<li>백엔드 서버의 포인트 변경 로직에 Redis ZADD 명령어 추가 후 배포</li>\n<li>배치 작업을 통해 데이터베이스의 데이터를 Redis에 추가</li>\n<li>데이터가 올바르게 들어갔는지 검증</li>\n<li>랭킹 시스템 적용 버전 배포</li>\n</ol>\n<h3 id=\"redis를-사용한-랭킹-시스템-적용-후\" style=\"position:relative;\"><a href=\"#redis%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%9E%AD%ED%82%B9-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%A0%81%EC%9A%A9-%ED%9B%84\" aria-label=\"redis를 사용한 랭킹 시스템 적용 후 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redis를 사용한 랭킹 시스템 적용 후</h3>\n<p>기존에 SQL문을 사용하던 때에는 포인트 TOP 10 목록을 조회하는데 대략 2~3초 정도 소요됐지만, Redis를 사용한 랭킹 시스템을 적용하고 나서는 평균 0.2초 정도로 90% 이상 조회 속도가 향상되었습니다.</p>\n<p>게다가 데이터베이스의 병목 지점도 제거되어 보다 안정적으로 높은 트래픽을 받아낼 수 있어 안정성도 향상된 모습을 보였습니다.</p>\n<p>다만 Redis에 저장된 데이터의 개수가 5~600만개 정도이고 대략 700MB를 차지하는데, 처음에 계산한 메모리 보다 더 많았어서 제한된 메모리에서 랭킹 시스템을 구축해야 하는 경우에는 체계적으로 메모리 계산을 해야할 것 같습니다.</p>\n<hr>\n<h3 id=\"출처\" style=\"position:relative;\"><a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>출처</h3>\n<ol>\n<li>\n<p>Redis 공식 홈페이지</p>\n<p><a href=\"https://redis.io/\" target=\"_blank\" rel=\"nofollow\">https://redis.io/</a></p>\n</li>\n<li>\n<p>Redisgate</p>\n<p><a href=\"http://redisgate.kr/redisgate/education/redis_education.php\" target=\"_blank\" rel=\"nofollow\">http://redisgate.kr/redisgate/education/redis_education.php</a></p>\n</li>\n<li>\n<p>Redis 랭킹 동점 처리 - 장형이의 일기</p>\n<p><a href=\"https://developstudy.tistory.com/89\" target=\"_blank\" rel=\"nofollow\">https://developstudy.tistory.com/89</a></p>\n</li>\n</ol>","frontmatter":{"title":"Redis Sorted Set을 활용한 랭킹 시스템 개발하기","date":"2024-01-10","summary":"순서 보장 없이 고유값을 저장하는 Redis의 Set 자료구조에 정렬 기능이 포함된 Sorted Set 자료구조를 활용해 랭킹 시스템을 구현하는 방법을 알아봅시다.","categories":["Backend"],"thumbnail":{"publicURL":"/static/0f54bf38e066cccac2d7b4ae0ed2f338/develop-ranking-system-using-redis-sorted-set.png","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAA6klEQVQoz41TYQ+CIBTs//83P+XKNre2XJuWiSCmgI9rkjWjTNge7xhv9zgONlgY1tp3XsPzsVkjwxw74O2vEfrF42xocFg2EuTVBRG+io024OcCtzRDe61w2R+R7VLotluU/Vey4RLylGNQGupcwnQKuhKgXgVKnnUkIjSNBKs5ai7AOEd5qxwWjZyuI+CEc8J716Hv1RS9y2pavz36R/jL3V8Nx2ZjBBHaSToxieFSY7hyF1QK8CzHNo4RRRGKolgn9J1zZKUA1S10zpAcDkiSBIyxMJf9X/CS/szLryHI5e8Hbj8aLf2WB04fs0vJbu1CAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/0f54bf38e066cccac2d7b4ae0ed2f338/0f157/develop-ranking-system-using-redis-sorted-set.png","srcSet":"/static/0f54bf38e066cccac2d7b4ae0ed2f338/c7aa3/develop-ranking-system-using-redis-sorted-set.png 192w,\n/static/0f54bf38e066cccac2d7b4ae0ed2f338/cff52/develop-ranking-system-using-redis-sorted-set.png 384w,\n/static/0f54bf38e066cccac2d7b4ae0ed2f338/0f157/develop-ranking-system-using-redis-sorted-set.png 768w","sizes":"(min-width: 768px) 768px, 100vw"},"sources":[{"srcSet":"/static/0f54bf38e066cccac2d7b4ae0ed2f338/04b43/develop-ranking-system-using-redis-sorted-set.webp 192w,\n/static/0f54bf38e066cccac2d7b4ae0ed2f338/7efec/develop-ranking-system-using-redis-sorted-set.webp 384w,\n/static/0f54bf38e066cccac2d7b4ae0ed2f338/803f0/develop-ranking-system-using-redis-sorted-set.webp 768w","type":"image/webp","sizes":"(min-width: 768px) 768px, 100vw"}]},"width":768,"height":449.99999999999994}}}},"tableOfContents":"<ul>\n<li><a href=\"#%EB%9E%AD%ED%82%B9-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B0%9C%EB%B0%9C-%EB%B0%B0%EA%B2%BD\">랭킹 시스템 개발 배경</a></li>\n<li><a href=\"#redis%EC%9D%98-sorted-set\">Redis의 Sorted Set</a></li>\n<li><a href=\"#%EC%A4%91%EB%B3%B5%EC%9D%B4-%EC%97%86%EB%8B%A4%EB%8A%94-%ED%8A%B9%EC%A7%95%EC%9C%BC%EB%A1%9C-%EC%9D%B8%ED%95%9C-%EB%8F%99%EC%A0%90%EC%9E%90-%EC%B2%98%EB%A6%AC-%EB%AC%B8%EC%A0%9C\">중복이 없다는 특징으로 인한 동점자 처리 문제</a></li>\n<li><a href=\"#nodejs-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EB%9E%AD%ED%82%B9-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\">Node.js 환경에서 랭킹 시스템 구현하기</a></li>\n<li><a href=\"#%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%A4%91%EB%8B%A8-%EC%97%86%EC%9D%B4-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%99%80-%EC%8B%B1%ED%81%AC-%EB%A7%9E%EC%B6%94%EA%B8%B0\">서비스 중단 없이 데이터베이스와 싱크 맞추기</a></li>\n<li><a href=\"#redis%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%9E%AD%ED%82%B9-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%A0%81%EC%9A%A9-%ED%9B%84\">Redis를 사용한 랭킹 시스템 적용 후</a></li>\n<li><a href=\"#%EC%B6%9C%EC%B2%98\">출처</a></li>\n</ul>"},"site":{"siteMetadata":{"siteUrl":"https://ji5485.github.io"}}},"pageContext":{"slug":"/post/2024-01-10/develop-ranking-system-using-redis-sorted-set/","prev":null,"next":{"slug":"/post/2023-10-15/aws-infrastructure-improvement-experience-1/","title":"AWS 초짜의 실시간으로 운영 중인 서비스 인프라 구조 개선 경험기 1편"}}},
    "staticQueryHashes": []}