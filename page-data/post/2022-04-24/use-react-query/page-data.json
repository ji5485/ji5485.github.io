{
    "componentChunkName": "component---src-page-template-blog-post-item-template-tsx",
    "path": "/post/2022-04-24/use-react-query/",
    "result": {"data":{"markdownRemark":{"html":"<h3 id=\"react-query는-어떤-라이브러리일까\" style=\"position:relative;\"><a href=\"#react-query%EB%8A%94-%EC%96%B4%EB%96%A4-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%9D%BC%EA%B9%8C\" aria-label=\"react query는 어떤 라이브러리일까 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React Query는 어떤 라이브러리일까?</h3>\n<p>먼저 공식 문서의 설명에 따르면 React Query 라이브러리는 Global State와의 어떠한 접촉 없이 손쉽게 데이터를 Fetch, Cache, Update 할 수 있도록 도와주는 라이브러리라고 명시되어 있습니다.</p>\n<p>공식 문서 첫 페이지에서는 사용하기 친숙해 간단하지만, 강력한 기능을 가졌다고 설명합니다.</p>\n<p>만약 이런 라이브러리 없이 서버 데이터를 가져오기 위해서는 아래와 같이 코드를 작성하면서 생길 수 있는 여러 문제점에 대해 고민해봐야 합니다.</p>\n<ul>\n<li>데이터 캐시 처리</li>\n<li>중복된 요청 단일화</li>\n<li>데이터 갱신 필요성 여부 파악</li>\n<li>성능 최적화 등</li>\n</ul>\n<p>Redux, Recoil, MobX 등과 같은 기존의 상태 관리 라이브러리는 클라이언트 쪽의 상태를 관리하기에는 좋지만, 한 번이라도 해당 라이브러리를 통해 비동기 작업을 진행해봤다면 이런 상태 관리 라이브러리를 통해서 서버 데이터를 관리하는 작업은 꽤나 힘들다고 생각할 것입니다.</p>\n<p>저 또한 Redux를 통해서 비동기 작업을 처리했던 경험이 있는데, 그 때 당시에는 위에 적혀있는 문제점들을 모두 겪었던 것 같습니다.</p>\n<p>캐시 처리는 직접 구현하려면 너무나도 고려해야 할 게 많았고, 캐시 처리가 안되니 당연히 데이터를 언제 갱신해야 하는지 여부를 파악하기 어려워 매번 요청을 보냈습니다.</p>\n<p>그렇게 되니 성능 최적화가 되지 않아 당연히 클라이언트쪽과 서버쪽 모두 부담이 됐죠.</p>\n<p>그렇게 직접 고생을 하고 나서 React Query에 대해 알게 됐고, 실제로 회사 프로젝트에 적용을 해봤는데 너무나도 사용하기 편리했습니다.</p>\n<h3 id=\"react-query를-도입하기-전\" style=\"position:relative;\"><a href=\"#react-query%EB%A5%BC-%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0-%EC%A0%84\" aria-label=\"react query를 도입하기 전 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React Query를 도입하기 전</h3>\n<p>아무리 React Query가 서버 데이터를 관리하기에 편리한 라이브러리라 하더라도, 이를 어떻게 프로젝트에 녹여내는지에 따라 효율이 천차만별로 달라질 것입니다.</p>\n<p>React Query를 도입하기 전의 회사 프로젝트에서는 프론트엔드 단에서 직접 스마트 컨트랙트에서 데이터를 호출했고, 그렇게 가져온 데이터를 모두 Recoil 라이브러리를 통해 관리해주고 있었습니다.</p>\n<p>그러다 여러 이유로 백엔드 서버 구축의 필요성을 느끼게 되었고, 그렇게 기존의 스마트 컨트랙트 데이터 호출 부분의 상당수를 서버단으로 옮기게 되어 이제는 API를 통해 데이터를 가져오도록 바뀌었습니다.</p>\n<p>그렇게 프론트엔드에서 API 처리를 위해 React Query 라이브러리를 사용하기로 결정했는데, 저는 당연히 이 라이브러리를 처음 사용해보는 입장이라 이를 어떻게 활용해야 효율을 끌어낼 수 있을지 궁금했기에 여러 레퍼런스랑 블로그 게시글을 찾아봤습니다.</p>\n<p>역시나 우아한 형제들, 카카오페이, 카카오 엔터테인먼트 등 다양한 대기업에서 이 라이브러리를 어떻게 더 잘 사용할 수 있을지 고민했던 점들을 공유했었죠.</p>\n<p>이렇게 찾아본 레퍼런스를 바탕으로 회사 프로젝트에 React Query를 적용했는데, 정말 간단하게 비동기 API 처리를 구현할 수 있었습니다.</p>\n<p>그럼 이제 React Query를 프로젝트에 적용하며 어떤 점이 좋았는지, 그리고 어떻게 라이브러리를 적용했는지 알아봅시다.</p>\n<h3 id=\"클라이언트-상태와-서버-데이터의-접점을-최소화하다\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%83%81%ED%83%9C%EC%99%80-%EC%84%9C%EB%B2%84-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98-%EC%A0%91%EC%A0%90%EC%9D%84-%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%98%EB%8B%A4\" aria-label=\"클라이언트 상태와 서버 데이터의 접점을 최소화하다 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클라이언트 상태와 서버 데이터의 접점을 최소화하다</h3>\n<p>React Query와 같은 Data Fetching 라이브러리가 등장하기 전까지는, 비동기 API 처리를 위해 Redux와 같은 상태 관리 라이브러리를 도입하는 경우도 꽤나 많았습니다.</p>\n<p>하지만 클라이언트 쪽에서만 사용하는 여러 상태와 같이 관리해야하므로 Store의 크기가 자연스럽게 커지게 되고, 이는 곧 확장 및 유지보수의 어려움으로 이어집니다.</p>\n<p>당연히 기존 상태 관리 라이브러리로는 캐시 처리나 오래된 데이터의 갱신도 구현하기 쉽지 않죠.</p>\n<p>따라서 이와 같이 별도의 처리가 필요한 서버 데이터는 따로 관리하는 편이 좋습니다.</p>\n<p>React Query도 서버 데이터를 전역 상태와 분리해서 관리해야한다는 입장이었기 때문에 Fetch한 모든 데이터를 Context API를 통해 관리해주고 있습니다.</p>\n<p>그렇기 때문에 서버 데이터 따로, 클라이언트 상태 따로 관리해줄 수 있었죠.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// 이렇게 특정 컴포넌트에서 todos라는 키로 데이터를</span>\n<span class=\"token comment\">// Fetch하게 되면 Context API를 통해 관리되므로</span>\n<span class=\"token function\">useQuery</span><span class=\"token punctuation\">(</span><span class=\"token string\">'todos'</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// 다음과 같이 Query Client를 통해 todos 키 값으로 Fetch되었던</span>\n<span class=\"token comment\">// 서버 데이터를 손쉽게 가져올 수 있습니다</span>\n<span class=\"token keyword\">const</span> queryClient <span class=\"token operator\">=</span> <span class=\"token function\">useQueryClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> todos <span class=\"token operator\">=</span> queryClient<span class=\"token punctuation\">.</span><span class=\"token function\">getQueryData</span><span class=\"token punctuation\">(</span><span class=\"token string\">'todos'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>하지만 특정 경우에는 클라이언트 쪽의 상태와 연동이 필요한 경우가 있습니다.</p>\n<p>마침 Recoil로 관리해주던 Form 값과 React Query를 양방향으로 맞춰주어야 하는 경우가 있었는데, 마침 useQuery의 옵션 중에서 onSuccess 라는 옵션이 있었습니다.</p>\n<p>이 옵션을 통해 Fetch가 성공한 경우에 Recoil State의 상태를 변경해주는 콜백 함수를 연결해줘 별도의 처리 없이 손쉽게 분리된 두 상태를 연동시킬 수 있었죠.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">useTodosQuery</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 클라이언트 상태 관리 코드</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>todos<span class=\"token punctuation\">,</span> setTodos<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useRecoilState</span><span class=\"token punctuation\">(</span>todosAtom<span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token function\">useQuery</span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">'todos'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// API 호출 코드</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">onSuccess</span><span class=\"token operator\">:</span> <span class=\"token parameter\">data</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Fetch된 데이터를 클라이언트 상태와 연동</span>\n      <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>이렇게 특정 경우를 제외하고는 손쉽게 서버 데이터와 클라이언트 상태를 분리해 관리할 수 있습니다.</p>\n<p>따라서 상태 관리 라이브러리를 프론트엔드 상태에 집중함으로써 더 적절한 용도로 사용할 수 있습니다.</p>\n<h3 id=\"api-별로-훅을-작성해-특성에-맞게-사용하다\" style=\"position:relative;\"><a href=\"#api-%EB%B3%84%EB%A1%9C-%ED%9B%85%EC%9D%84-%EC%9E%91%EC%84%B1%ED%95%B4-%ED%8A%B9%EC%84%B1%EC%97%90-%EB%A7%9E%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8B%A4\" aria-label=\"api 별로 훅을 작성해 특성에 맞게 사용하다 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>API 별로 훅을 작성해 특성에 맞게 사용하다</h3>\n<p>이 부분은 if(kakao) 2021의 웹 프론트엔드 세션 중에서 <a href=\"https://if.kakao.com/session/118\" target=\"_blank\" rel=\"nofollow\">카카오페이 프론트엔드 개발자들이 React Query를 선택한 이유</a> 세션을 많이 참고했습니다.</p>\n<br />\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 768px; \n        width: 100%;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.15);\n      \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5f4105ae1a42024f1441f5ed6039481f/66e9f/use-react-query-1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.083333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABPUlEQVQoz41S26qCUBT01rEsLyXdSQTtRkESBZUP0nPRn/RVx/+cwywQ7GbnYWDvpTN7Zq2lKIqCMlzXxXA4xGAwwGg0QqfTge/7aDQa0DQNlmXBNE35l/dnvvJc0HVdyPV6HbVa7YHU7Xax3+8xm83eCb0XbDabiKIIQRDAtm25b7dbcUvnp9MJ6/Va6nz8qyAjU+B4PCKOY4me5zmu1ysMwxD3rVYLYRjK+aug4ziYTqfYbDaYTCbo9XrI818cDgf0+/2HJP/qIWNSlC545kDu9zsWi4W4V1W1qn+vggRJBQoXH9xUC5I0Ho9lIHTDWIWjdrst/WSd8DxPklQKsulcifl8LuTy/q1WK5zPZ6RpKtjtdlgul68t0DRdCPxgmj/yahl0xn4mSYLb7YbL5YIsywQcHFeHfELXdPwBHM/o34HbaLAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/5f4105ae1a42024f1441f5ed6039481f/a59e9/use-react-query-1.webp 192w,\n/static/5f4105ae1a42024f1441f5ed6039481f/0ca9f/use-react-query-1.webp 384w,\n/static/5f4105ae1a42024f1441f5ed6039481f/dc9b9/use-react-query-1.webp 768w,\n/static/5f4105ae1a42024f1441f5ed6039481f/e2c2f/use-react-query-1.webp 1152w,\n/static/5f4105ae1a42024f1441f5ed6039481f/f3efb/use-react-query-1.webp 1536w,\n/static/5f4105ae1a42024f1441f5ed6039481f/2d0e9/use-react-query-1.webp 5120w\"\n              sizes=\"(max-width: 768px) 100vw, 768px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/5f4105ae1a42024f1441f5ed6039481f/3b721/use-react-query-1.png 192w,\n/static/5f4105ae1a42024f1441f5ed6039481f/66595/use-react-query-1.png 384w,\n/static/5f4105ae1a42024f1441f5ed6039481f/fe486/use-react-query-1.png 768w,\n/static/5f4105ae1a42024f1441f5ed6039481f/d2d74/use-react-query-1.png 1152w,\n/static/5f4105ae1a42024f1441f5ed6039481f/e8464/use-react-query-1.png 1536w,\n/static/5f4105ae1a42024f1441f5ed6039481f/66e9f/use-react-query-1.png 5120w\"\n            sizes=\"(max-width: 768px) 100vw, 768px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/5f4105ae1a42024f1441f5ed6039481f/fe486/use-react-query-1.png\"\n            alt=\"./use-react-query-1.png\"\n            title=\"./use-react-query-1.png\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<br />\n<p>지금의 회사 프로젝트 구조를 잡는데 많은 도움이 됐던 세션입니다.</p>\n<p>카카오페이에서는 React Query를 사용할 때, API 별로 커스텀 훅을 만들어 관리해준다고 했습니다.</p>\n<p>이렇게 API 별로 커스텀 훅을 만들어주는 경우에는 보다 더 직관적으로 API를 사용할 수 있고, API 전/후처리가 간편하며, API 별로 옵션을 다르게 설정할 수 있는 등 다양한 장점을 얻을 수 있다고 했죠.</p>\n<p>실제로 프로젝트에 적용해보니 커스텀 훅 네이밍을 통해 더 명확하게 어떤 API인지 알 수 있었고, API 별로 특성에 맞도록 옵션을 설정함으로써 더 효율적으로 Fetch 할 수 있었으며, 손쉽게 전/후처리가 가능했습니다.</p>\n<p>또, API 별로 만들어준 커스텀 훅 파일 안에 리턴값 타입과 Fetch 함수를 한꺼번에 관리가 가능해 개발 및 유지보수가 너무나도 간편했습니다.</p>\n<p>그동안 비동기 처리를 위해 Redux를 사용했던 것이 얼마나 큰 고생이었는지 이때 뼈저리게 알게 되었죠.</p>\n<p>아래 코드는 실제 프로젝트에서 사용하고 있는 코드를 조금 바꾼 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useQuery <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react-query'</span>\n<span class=\"token keyword\">import</span> axios <span class=\"token keyword\">from</span> <span class=\"token string\">'../axiosConfig'</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useManageAvatarState <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../../state/avatarState'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">AvatarType</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  id<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">loadAvatar</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name<span class=\"token operator\">:</span> string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">await</span> axios<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">/api/~~/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">useAvatarQuery</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name<span class=\"token operator\">?</span><span class=\"token operator\">:</span> string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> setAvatarState <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useManageAvatarState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token generic-function\"><span class=\"token function\">useQuery</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>AvatarType<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">'avatar'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>\n        data<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> data <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">loadAvatar</span><span class=\"token punctuation\">(</span>name <span class=\"token keyword\">as</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span>\n\n      <span class=\"token keyword\">return</span> data\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>\n      enabled<span class=\"token operator\">:</span> name <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">,</span>\n      staleTime<span class=\"token operator\">:</span> <span class=\"token number\">Infinity</span><span class=\"token punctuation\">,</span>\n      retry<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n      retryOnMount<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n      refetchOnWindowFocus<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n      refetchOnMount<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n      refetchOnReconnect<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n      <span class=\"token function-variable function\">onSuccess</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> avatar <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setAvatarState</span><span class=\"token punctuation\">(</span>avatar<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 하나의 파일 안에 리턴값의 타입, Fetch 함수, useQuery Hook을 한꺼번에 관리하고 있습니다.</p>\n<p>또, API의 특성에 맞도록 옵션을 설정해주고 있으며 후처리로 프론트엔드 상태와 연동시켜주는 작업까지 진행하고 있죠.</p>\n<p>이와 같이 useQuery를 사용함으로써, 저희는 비동기 API 처리를 위한 부가적인 작업 없이 오로지 핵심 부분에만 집중해서 코드를 작성할 수 있었습니다.</p>\n<p>옵션만 적절하게 넣어주면 나머지는 React Query가 알아서 처리를 해주니 크게 신경쓸 필요가 없어서 너무 편리했습니다.</p>\n<h3 id=\"사용-범위를-스마트-컨트랙트까지-확장하다\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9-%EB%B2%94%EC%9C%84%EB%A5%BC-%EC%8A%A4%EB%A7%88%ED%8A%B8-%EC%BB%A8%ED%8A%B8%EB%9E%99%ED%8A%B8%EA%B9%8C%EC%A7%80-%ED%99%95%EC%9E%A5%ED%95%98%EB%8B%A4\" aria-label=\"사용 범위를 스마트 컨트랙트까지 확장하다 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용 범위를 스마트 컨트랙트까지 확장하다</h3>\n<p>그동안 스마트 컨트랙트를 통해 호출한 데이터는 단순히 컴포넌트 내의 useState 또는 Recoil State로 관리를 해주고 있었습니다.</p>\n<p>또, 단순히 데이터를 호출해 넣어주기만 함으로써 지금 데이터가 Fetching 중인지, Fetch 됐는지 알 길이 없고, 어떤 데이터가 오래된 데이터인지 파악하기 힘들었죠.</p>\n<p>물론 이를 위해 추가적으로 작업을 해줄 수도 있었지만, 난이도가 꽤나 높아질 것 같아 그동안은 이런 부가적인 기능 없이 스마트 컨트랙트를 프론트엔드에서 불러와 사용하고 있었습니다.</p>\n<p>당연히 이는 데이터를 불러오고 있는지, 다 불러왔는지, 불러오다가 에러가 난 건지, 이 데이터가 오래된 건지 아닌지에 대해 사용자는 알 방법이 없으므로 자연스럽게 사용자 경험은 악화되기 마련입니다.</p>\n<p>하지만 스마트 컨트랙트 데이터 호출도 마찬가지로 비동기 처리이므로 useQuery를 사용하게 되면, API 요청을 처리하는 것처럼 사용이 가능하기 때문에 더 손쉽게 데이터를 관리할 수 있게되죠.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// 사용자가 가지고 있는 토큰 수량을 반환하는 Custom Hook</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">useLoadUserBalance</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">address<span class=\"token operator\">?</span><span class=\"token operator\">:</span> string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">useQuery</span><span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">[</span><span class=\"token string\">'balance'</span><span class=\"token punctuation\">,</span> address<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> balance <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token constant\">TOKEN_CONTRACT</span><span class=\"token punctuation\">.</span>methods<span class=\"token punctuation\">.</span><span class=\"token function\">balanceOf</span><span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> caver<span class=\"token punctuation\">.</span>utils<span class=\"token punctuation\">.</span><span class=\"token function\">convertFromPeb</span><span class=\"token punctuation\">(</span>balance<span class=\"token punctuation\">,</span> <span class=\"token string\">'KLAY'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>\n      enable<span class=\"token operator\">:</span> address <span class=\"token operator\">!==</span> undeined<span class=\"token punctuation\">,</span>\n      refetchInterval<span class=\"token operator\">:</span> <span class=\"token constant\">REFETCH_INTERVAL_TIME</span><span class=\"token punctuation\">,</span>\n      suspense<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 옵션을 걸어 사용하게 되면 다른 어떠한 부가적인 로직에 신경쓸 필요가 없어집니다.</p>\n<p>특히나 suspense 옵션을 통해 Fetching 상태일 때 Loading Shimmer를 띄워주는 등의 처리도 가능하죠.</p>\n<p>그렇게 되면 사용자는 현재 데이터 로딩 상태를 명확하게 알 수 있어 사용자 경험을 끌어올릴 수 있는 것입니다.</p>\n<h3 id=\"마치며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치며</h3>\n<p>이렇게 장점이 많은 React Query이지만, Redux처럼 많이 사용되는 개발 컨벤션이 따로 없어 당연하게도 프로젝트가 커지면 커질수록 복잡도도 같이 올라갈 것입니다.</p>\n<p>하지만 이는 반대로 말하면 올바른 컨벤션을 확립하고 이를 토대로 개발하면 React Query가 가진 장점을 최대한 활용할 수 있다는 말이 되겠죠.</p>\n<p>그러기 위해서는 끊임없이 구조를 개선하기 위해 고민해야만 하는 것 같습니다.</p>\n<hr>\n<h3 id=\"source\" style=\"position:relative;\"><a href=\"#source\" aria-label=\"source permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Source</h3>\n<ul>\n<li>\n<p>React Query</p>\n<p><a href=\"https://react-query.tanstack.com/\" target=\"_blank\" rel=\"nofollow\">https://react-query.tanstack.com/</a></p>\n</li>\n<li>\n<p>Store에서 비동기 통신 분리하기 (feat. React Query)</p>\n<p><a href=\"https://techblog.woowahan.com/6339/\" target=\"_blank\" rel=\"nofollow\">https://techblog.woowahan.com/6339/</a></p>\n</li>\n<li>\n<p>카카오페이 프론트엔드 개발자들이 React Query를 선택한 이유</p>\n<p><a href=\"https://if.kakao.com/session/118\" target=\"_blank\" rel=\"nofollow\">https://if.kakao.com/session/118</a></p>\n</li>\n</ul>","frontmatter":{"title":"React Query를 사용하며","date":"2022-04-24","summary":"React Query를 어떻게 써야 효율적으로 사용할 수 있을지 고민하고 찾아보면서 프로젝트에 적용한 경험을 공유해보았습니다.","categories":["Web","Frontend","React","OpenSource"],"thumbnail":{"publicURL":"/static/d20dd4f6fdf7ef0a5338f79f2df70d76/use-react-query.png","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAA7EAAAOxAGVKw4bAAABBklEQVQoz62TXUrDUBCFsxZXoeBe3IJPfRFXYF8Fd+CbD9pUi4XWvlhKbW5AsLn4g6TREgQJCEKTuZ+YIE01TbD0wGWGM8PhzAzXYs2wyorGmCyKIHGCEbPA/0twLmaK+SWi5Q5F0vhy+4A6OuU9CBf4lRzOPmNOdnbZ39ygU6uTZMVqh/lR5HtnItnuDJzv1TnY2mZweJz2JHE87/m1AqvI1R/MhI+nt8rjFToMw5CR4zD2PPzJBK01d96Y++dHHKXwfZ/hzRDlumlfFEXFDn+IIAi4bLe57vfxtOaq16PT7aKUS8O2U9FGs8lFq8WZbfM6na4wcgVKR84fRfL5kld6lHV8vS9PDaKYQsGhzQAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/d20dd4f6fdf7ef0a5338f79f2df70d76/0f157/use-react-query.png","srcSet":"/static/d20dd4f6fdf7ef0a5338f79f2df70d76/c7aa3/use-react-query.png 192w,\n/static/d20dd4f6fdf7ef0a5338f79f2df70d76/cff52/use-react-query.png 384w,\n/static/d20dd4f6fdf7ef0a5338f79f2df70d76/0f157/use-react-query.png 768w","sizes":"(min-width: 768px) 768px, 100vw"},"sources":[{"srcSet":"/static/d20dd4f6fdf7ef0a5338f79f2df70d76/04b43/use-react-query.webp 192w,\n/static/d20dd4f6fdf7ef0a5338f79f2df70d76/7efec/use-react-query.webp 384w,\n/static/d20dd4f6fdf7ef0a5338f79f2df70d76/803f0/use-react-query.webp 768w","type":"image/webp","sizes":"(min-width: 768px) 768px, 100vw"}]},"width":768,"height":449.99999999999994}}}},"tableOfContents":"<ul>\n<li><a href=\"#react-query%EB%8A%94-%EC%96%B4%EB%96%A4-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%9D%BC%EA%B9%8C\">React Query는 어떤 라이브러리일까?</a></li>\n<li><a href=\"#react-query%EB%A5%BC-%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0-%EC%A0%84\">React Query를 도입하기 전</a></li>\n<li><a href=\"#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%83%81%ED%83%9C%EC%99%80-%EC%84%9C%EB%B2%84-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98-%EC%A0%91%EC%A0%90%EC%9D%84-%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%98%EB%8B%A4\">클라이언트 상태와 서버 데이터의 접점을 최소화하다</a></li>\n<li><a href=\"#api-%EB%B3%84%EB%A1%9C-%ED%9B%85%EC%9D%84-%EC%9E%91%EC%84%B1%ED%95%B4-%ED%8A%B9%EC%84%B1%EC%97%90-%EB%A7%9E%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8B%A4\">API 별로 훅을 작성해 특성에 맞게 사용하다</a></li>\n<li><a href=\"#%EC%82%AC%EC%9A%A9-%EB%B2%94%EC%9C%84%EB%A5%BC-%EC%8A%A4%EB%A7%88%ED%8A%B8-%EC%BB%A8%ED%8A%B8%EB%9E%99%ED%8A%B8%EA%B9%8C%EC%A7%80-%ED%99%95%EC%9E%A5%ED%95%98%EB%8B%A4\">사용 범위를 스마트 컨트랙트까지 확장하다</a></li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></li>\n<li><a href=\"#source\">Source</a></li>\n</ul>"},"site":{"siteMetadata":{"siteUrl":"https://ji5485.github.io"}}},"pageContext":{"slug":"/post/2022-04-24/use-react-query/","prev":{"slug":"/post/2022-06-01/importance-of-404-error-page/","title":"쉽게 지나칠 수 있는 404 에러 페이지의 중요성"},"next":{"slug":"/post/2022-02-02/rethinking-react-atomic-design/","title":"React Atomic Design을 재고하다"}}},
    "staticQueryHashes": []}